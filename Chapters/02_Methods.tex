\chapter{Methods}

% Write your methods here.
\section{Hardware Specifications}
The tests were run on a laptop with the following specifications:
\begin{itemize}
    \item CPU Model: Intel Core i5-10210U
    \item CPU Cores: 4\cite{intel}
    \item CPU Threads: 8\cite{intel}
    \item CPU Base Frequency: 1.60 GHz\cite{intel}
    \item CPU Max Turbo Frequency: 4.20 GHz\cite{intel}
    \item RAM: 16 GB DDR4 2933 MT/s
    \item Storage: 512 GB NVMe SSD
\end{itemize}
In order to ensure minimal interference, the tests were run with no other applications (other than the IDE itself) running, 
and with the laptop plugged in and heavy background processes like Windows Update disabled.

\section{Python Environment}
Here are the details of the Python environment used for the implementation and testing of the algorithms:

\begin{table}[H]
\begin{tabularx}{\textwidth}{|l|X|}
    \hline
    \textbf{Python Version} & 3.13.12 \\
    \hline
    \textbf{Operating System} & Windows 11 Pro 64-bit (version 25H2) \\
    \hline
    \textbf{IDE} & Visual Studio Code (version 1.109.5) \\
    \hline
    \textbf{Environment Manager} & Miniforge (conda version 26.1.0) \\
    \hline
    \textbf{Packages Used} & 
    \begin{tabular}{ll}
        \textbf{Package} & \textbf{Version} \\
        \hline
        time & built-in \\
        tracemalloc & built-in \\
        sys & built-in \\
        matplotlib & 3.10.8 \\
        pandas & 3.0.1 \\
        jupyter & 1.1.1 \\
        Jinja2 & 3.1.6 \\
    \end{tabular}
    \\
    \hline
\end{tabularx}
\caption{Details of the Python environment used for implementation and testing}
\label{tab:python_environment}
\end{table}

\section{Test Data}

To ensure a comprehensive evaluation of the algorithms, synthetic test data was generated using three different alphabets and five different scenarios,
each designed to cover a wide range of cases that could be encountered in real-world applications, with a particular focus on the field of bioinformatics, 
where the \acrshort{lcs} problem is particularly relevant due to the nature of \gls{dna} and \gls{rna} sequences being represented as strings.

The alphabets used for the test data were as follows:
\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}
    \begin{tabularx}{\textwidth}{|l|X|X|}
        \hline
        \textbf{Alphabet Name} & \textbf{Description} & \textbf{Characters}\\
        \hline
        Full & Every lowercase letter & a, b, c, ..., z \\
        \hline
        DNA & The four DNA \gls{base}s & A, C, G, T \\
        \hline
        Disjoint & Two disjoint sets of the lowercase letters & \makecell[l]{String 1: a, b, c, ..., m\\String 2: n, o, p, ..., z}\\
        \hline
    \end{tabularx}
    \caption{Description of the alphabets used for generating test data}
    \label{tab:alphabets}
\end{table}

Five separate scenarios were tested, in order to cover as wide a range of cases as possible:
\begin{table}[H]
    \renewcommand{\arraystretch}{1.5}
    \begin{tabularx}{\textwidth}{|l|X|l|}
        \hline
        \textbf{Scenario Name} & \textbf{Description} & \textbf{Alphabet}\\
        \hline
        random\_uniform & Both strings are generated randomly with a uniform distribution of characters & Full \\
        \hline
        mutated\_implant & A common motif is implanted in both strings with mutations & DNA \\
        \hline
        repetitive\_with\_noise & Strings are formed by repeating a pattern with some mutations & DNA \\
        \hline
        near\_identical & Strings are nearly identical, with minor mutations preferentially at the edges & Full \\
        \hline
        disjoint\_alphabet & Strings are generated from completely disjoint alphabets & Disjoint \\
        \hline
    \end{tabularx}
    \caption{Description of test scenarios used for benchmarking}
    \label{tab:test_scenarios}
\end{table}

The justifications for the choice of these scenarios are:
\begin{itemize}
    \item The \textit{random\_uniform} scenario serves as a baseline for the performance of the algorithms on completely random data.
    \item The \textit{mutated\_implant} scenario simulates a common real-world case in bioinformatics, where two otherwise unrelated long sequences share a relatively short common motif between them at unrelated positions\cite{interspersedrepeats,transposons}. It's basically the "needle in a haystack" scenario.
    \item The \textit{repetitive\_with\_noise} scenario simulates another common case in bioinformatics, where sequences are formed by repeating a pattern (tandem repeats\cite{tandemrepeats}) with some mutations, which can lead to multiple short \acrshort{lcs}s.
    \item The \textit{near\_identical} scenario tests the performance of the algorithms on strings that are nearly identical, so that there would be one very long \acrshort{lcs} which would have to be held in memory.
    \item The \textit{disjoint\_alphabet} scenario tests the case where the two strings have no common characters, which should result in an \acrshort{lcs} of length 0. The algorithms would have to traverse the entire data structure to determine this.
It also serves as a sanity check to ensure that the algorithms are correctly identifying the lack of common substrings.
\end{itemize}

\section{Design}
The algorithms themselves were implemented in pure Python (version 3.13.12), without the aid of any external libraries 
(although external libraries were used for gathering the results and plotting the graphs).

The \acrshort{sam} was implemented using the standard on-line construction algorithm\cite{sammake}.
To find the \acrshort{lcs} of the first string and the second string, the \acrshort{sam} was created with the first string, 
and then traversed through by the second string, keeping track of the longest match found.

To give the \acrfull{sa} the best chance possible, the \acrshort{sa} was constructed using the \acrfull{sais} algorithm, 
the current state-of-the-art algorithm for constructing it in linear time\cite{sais}.
The \acrshort{sa} was constructed for the concatenated string of the two strings being compared, 
with a \gls{sentinel} character in between them (\textbackslash0 in this case) to separate them.
The \acrshort{lcp} array was constructed using Kasai's algorithm\cite{kasai}, which is a linear time algorithm for constructing it from the \acrshort{sa}.
The \acrshort{esa} was essentially implemented as a combination of the \acrshort{sa} and the \acrshort{lcp} array.

\textbf{25 string pairs} each of lengths 100, 500, 1000, 5000, and 10,000 characters were generated for each scenario, 
and each string pair was tested on both algorithms \textbf{20 times} to try and ensure statistical significance of the results.
To ensure reproducibility, the random seed used for generating the string pairs was fixed at 42 for all scenarios and string lengths.

The testing code was designed to run both algorithms on the same string pairs, and to measure both the time taken and the peak memory usage for each run.
The time taken was measured using the \texttt{time} module, while the peak memory usage was measured using the \texttt{tracemalloc} module, which is a built-in Python module for tracking memory allocations.
The index size for each algorithm was computed using the \texttt{sys.getsizeof} function, which returns the size of an object by recursively summing the sizes of all referenced objects.

The full testing code, including a requirements file and instructions for running it, is provided in the supplementary materials. 
A complete list of generated string pairs with their corresponding LCS values, as well as the raw test results, are also included. 
Additionally, the code used for plotting the results (using the \texttt{matplotlib} library) is provided.