\chapter{Methods}

% Write your methods here.
\section{Hardware and Software}
The tests were run on a laptop with the following specifications:
\begin{itemize}
    \item CPU Model: Intel Core i5-10210U
    \item CPU Cores: 4\cite{intel}
    \item CPU Threads: 8\cite{intel}
    \item CPU Base Frequency: 1.60 GHz\cite{intel}
    \item CPU Max Turbo Frequency: 4.20 GHz\cite{intel}
    \item RAM: 16 GB DDR4 2933 MT/s
    \item Storage: 512 GB NVMe SSD
    \item Operating System: Windows 11 Pro 64-bit
    \item IDE: Visual Studio Code (version 1.109.5)
\end{itemize}
In order to ensure minimal interference, the test were run with no other applications (other than the IDE itself) running in the background, 
and with the laptop plugged in and heavy background processes like Windows Update disabled.

\section{Design}
The algorithms themselves were implemented in pure Python (version 3.13.12), without the aid of any external libraries 
(although external libraries were used for gathering the results and plotting the graphs).

The \acrlong{sam} was implemented using the standard on-line construction algorithm.

The \acrlong{sa} was constructed using the \acrfull{sais} algorithm, the current state-of-the-art algorithm for constructing it in linear time\cite{sais}.
The \acrshort{lcp} Array was constructed using Kasai's algorithm\cite{kasai}, which is a linear time algorithm for constructing it from the \acrshort{sa}.

\section{Test Data}

To ensure a comprehensive evaluation of the algorithms, test data was generated using three different alphabets and five different scenarios,
as described in the following tables.

The alphabets used for the test data were as follows:
\begin{table}[h]
    \renewcommand{\arraystretch}{1.5}
    \begin{tabularx}{\textwidth}{|l|X|X|}
        \hline
        \textbf{Alphabet Name} & \textbf{Description} & \textbf{Characters}\\
        \hline
        Full & Every lowercase letter & a, b, c, ..., z \\
        \hline
        DNA & The four DNA \gls{base}s & A, C, G, T \\
        \hline
        Disjoint & Two disjoint sets of the lowercase letters & \makecell[l]{String 1: a, b, c, ..., m\\String 2: n, o, p, ..., z}\\
        \hline
    \end{tabularx}
    \caption{Description of the alphabets used for generating test data}
    \label{tab:alphabets}
\end{table}

Five separate scenarios were tested, in order to cover as wide a range of cases as possible:
\begin{table}[h]
    \renewcommand{\arraystretch}{1.5}
    \begin{tabularx}{\textwidth}{|l|X|l|}
        \hline
        \textbf{Scenario Name} & \textbf{Description} & \textbf{Alphabet}\\
        \hline
        random\_uniform & Both strings are generated randomly with a uniform distribution of characters & Full \\
        \hline
        mutated\_implant & A common motif is implanted in both strings with mutations & DNA \\
        \hline
        repetitive\_with\_noise & Strings are formed by repeating a pattern with some mutations & DNA \\
        \hline
        near\_identical & Strings are nearly identical, with minor mutations preferentially at the edges & Full \\
        \hline
        disjoint\_alphabet & Strings are generated from completely disjoint alphabets & Disjoint \\
        \hline
    \end{tabularx}
    \caption{Description of test scenarios used for benchmarking}
    \label{tab:test_scenarios}
\end{table}

\textbf{25 string pairs} each of lengths 100, 500, 1000, 5000, and 10,000 characters were generated for each scenario, 
and each string pair was tested on both algorithms \textbf{20 times} to try and ensure statistical significance of the results.
To ensure reproducibility, the random seed used for generating the string pairs was fixed at 42 for all scenarios and string lengths.

The generated string pairs, along with their \acrshort{lcs} values, are provided in the supplementary materials.