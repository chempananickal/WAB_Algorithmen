\chapter{Results}
% Write your results here.

\section{Choice of Central Tendency}
The data collected seems to be heavily right-skewed, with some outliers. This is irrespective of the scenario, string length, algorithm, 
or even the type of measurement (build time, query time, total time, or memory usage).

This is likely due to cache misses, other background processes running on the computer, 
or other random factors that can affect the performance of the algorithms in a non-deterministic way.
Therefore, the \textbf{median} was chosen as the measure of central tendency for the results, 
as the data is not normally distributed and the median is more robust to outliers than the mean.
And since the median is being used, the interquartile range (\acrshort{iqr}) was chosen as the measure of variability.

Tables with the exact values of the median and \acrshort{iqr} for all measurements are included in the appendix (page~\pageref{app:tables}) grouped by scenario, and the plots in the main text are based on these values.
An even more detailed summary is available as a CSV file in the supplementary materials, which includes other statistics such as the mean and standard deviation.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth, height=0.25\textheight]{Code/Results/plots/distribution_plot.pdf}
    \caption{Distribution of total time for the \acrshort{sam} and the \acrshort{esa} for the random uniform scenario and string length 10000, as an example of the right-skewed nature of the data}
    \label{fig:distribution_plot}
\end{figure}

\section{Time}
The time taken to construct the \acrshort{sam} and the \acrshort{esa} and to find the \acrshort{lcs} was measured for each scenario and string length, 
and the results are shown in the following plots. 

The build time, query time, and total time are shown separately to give a more detailed view of the performance of the algorithms.
The median is shown as a line, and the \acrshort{iqr} is shown as a shaded area around the line.
Because the \acrshort{iqr} is very small for most of the data points, it may not be visible in the plots.

\subsection{Build Time}

The build time is the time taken to construct the data structure (the \acrshort{sam} or the \acrshort{esa}) from the string(s).

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Code/Results/plots/build_time_median_iqr.pdf}
    \caption{Median and interquartile range (\acrshort{iqr}) of build time for the \acrshort{sam} and the \acrshort{esa} across different scenarios and string lengths}
    \label{fig:build_time}
\end{figure}

As can be seen from the plot, the build time for both algorithms tend to follow a linear trend with respect to the string length (as is to be expected),
but the \acrshort{esa} has a much higher build time than the \acrshort{sam}, especially as the string length increases.

\subsection{Query Time}

The query time is the time taken to find the \acrshort{lcs} of the two strings using the constructed data structure.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Code/Results/plots/query_time_median_iqr.pdf}
    \caption{Median and interquartile range (\acrshort{iqr}) of query time for the \acrshort{sam} and the \acrshort{esa} across different scenarios and string lengths}
    \label{fig:query_time}
\end{figure}

The query time for both algorithms also tends to follow a linear trend with respect to the string length, and for most cases, 
the \acrshort{sam} has a shorter query time than the \acrshort{esa}, with near\_identical being the only exception.
This outlier can be explained by the fact that in the near\_identical scenario, where the \acrshort{lcs} is singular and very long,
causing the \acrshort{sam} to have to traverse a long path in the automaton, 
whereas the \acrshort{esa} can find the \acrshort{lcs} by directly inspecting the \acrshort{lcp} between the relevant suffixes, and that too, only once.
This leads to the interesting observation that \textit{the query time of the \acrshort{sam} grows in proportion to the length of the \acrshort{lcs}}, at least in Python.

Also note that the query time for both algorithms is extremely small compared to the build time,
and even with string pairs that are each 10,000 characters long, the median query time remained under 0.1 seconds.

\clearpage
\subsection{Total Time}

The total time represents the time from the start of the construction of the data structure to the end of finding the \acrshort{lcs}, 
so it is essentially the sum of the build time and the query time.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Code/Results/plots/total_time_median_iqr.pdf}
    \caption{Median and interquartile range (\acrshort{iqr}) of total time for the \acrshort{sam} and the \acrshort{esa} across different scenarios and string lengths}
    \label{fig:total_time}
\end{figure}

Because the build time was so high for the \acrshort{esa} compared to the \acrshort{sam}, 
the total time for the \acrshort{esa} is also much higher than that of the \acrshort{sam} across all scenarios and string lengths,
with the difference becoming more pronounced as the string length increases.

This is in spite of the fact that the \acrshort{esa} was built with the \acrshort{sais} and Kasai's algorithms,
avoiding the traditional naive algorithms which would have used Python's built-in sorting, 
rendering the time complexity to be \textit{O(nlog n)} for a combined string of length \textit{n}.